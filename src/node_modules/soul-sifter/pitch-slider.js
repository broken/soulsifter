import { css, html, LitElement } from "@polymer/lit-element";

import "@polymer/paper-slider/paper-slider.js";
import { Debouncer } from '@polymer/polymer/lib/utils/debounce.js';
import { timeOut } from '@polymer/polymer/lib/utils/async.js';

import { BpmMixin } from "./mixin-bpm.js";
import { SongMixin } from "./mixin-song.js";


class PitchSlider extends SongMixin(BpmMixin(LitElement)) {
  render() {
    return html`
      <paper-slider editable pin value="${this.pitch}" step="0.1" min="${this.pitchPctMin}" max="${this.pitchPctMax}" @change="${this.pitchChanged}"></paper-slider>
    `;
  }

  static get properties() {
    return {
      pitchPctMax: { type: Number },
      pitchPctMin: { type: Number },
    }
  }

  constructor() {
    super();
    this.pitch = 0;
    this.bpm = 0;
    this.song = new ss.Song();
    this.pitchPctMin = -8;
    this.pitchPctMax = 8;
    this.userPitchChange = true;
  }

  // Used for comparing BPMs when determining pitch shifts
  canonicalizeBpm(bpm) {
    if (bpm === 0) return bpm;
    if (bpm >= 150) return this.canonicalizeBpm(bpm / 2);
    if (bpm < 75) return this.canonicalizeBpm(bpm * 2);
    return bpm;
  }

  songChanged(song) {
    this.song = song;
    if (!song || !song.bpm) return;
    if (!this.bpm) {
      this.changeBpm(parseFloat(song.bpm).toFixed(1));
    } else {
      this.updatePitch();
    }
  }

  bpmChanged(bpm) {
    this.bpm = bpm;
    this.updatePitch();
  }

  pitchChanged(e) {
    this.pitch = e.target.value;
    if (this.userPitchChange && !!this.song && !!this.song.bpm) {
      this.changeBpm((this.song.bpm * (this.pitch/100) + this.song.bpm * 1).toFixed(1));
      this.userPitchChange = false;
    }
    // we debounce the reset here since changing the bpm can cause the pitchChanged observer to be called multiple times
    this.debouncer = Debouncer.debounce(
        this.debouncer,  // initially undefined
        timeOut.after(50),
        () => this.userPitchChange = true);
  }

  updatePitch() {
    if (!this.bpm || !this.song || !this.song.bpm) return;
    this.userPitchChange = false;
    let pitch = this.canonicalizeBpm(this.bpm) / this.canonicalizeBpm(this.song.bpm);
    pitch = (pitch - 1) * 100;
    if (pitch > this.pitchPctMax) pitch = this.pitchPctMax;
    if (pitch < this.pitchPctMin) pitch = this.pitchPctMin;
    this.pitch = pitch;
  }

  static get styles() {
    return [
      css`
        paper-slider::shadow paper-input::shadow paper-input-decorator {
          padding: 0 0 2px 0;
        }
        paper-slider::shadow paper-input::shadow input[is="core-input"] {
          margin: 0.25em 0;
        }
        paper-slider::shadow #sliderContainer {
          margin: 0;
        }
      `,
    ];
  }
}

window.customElements.define('pitch-slider', PitchSlider);
