// <link href="../iron-signals/iron-signals.html" rel="import">
// <link href="../core-tooltip/core-tooltip.html" rel="import">

// <link href="song-list-item.html" rel="import">
// <link href="ss-global-behavior.html" rel="import">

import { html, LitElement } from "@polymer/lit-element";

import { } from "./song-list-item.js";

class SongList extends LitElement {
  render() {
    let songListItems = this.songs.map(s => html`<song-list-item .song="${s}"></song-list-item>`);
    return html`
      ${songListItems}
    `;
  }
  static get properties() {
    return {
      songs: { type: Array },
      song: { type: Object },
      playlist: { type: Object },
      genres: { type: Array },
      query: { type: String },
      bpm: { type: Number },
      songTrail: { type: Array },
      searchOptionBpmRestrict: { type: Boolean },
      searchOptionKeyRestrict: { type: Boolean },
      searchOptionTrashedRestrict: { type: Boolean },
      searchOptionRepeatRestrict: { type: Boolean },
    }
  }

  constructor() {
    super();
    this.genres = [];
    this.query = '';
    this.songTrail = [];
    this.searchOptionBpmRestrict = false;
    this.searchOptionKeyRestrict = false;
    this.searchOptionTrashedRestrict = false;
    this.searchOptionRepeatRestrict = false;
    this.search();
  }

  search() {
    // this.$.tooltip.show = true;
    // give the tooltip a chance to show
    // setTimeout(function() {
      if (!!this.playlist) {
        // var playlist = that.global.playlist;
        // if (!playlist.query) {
        //   var entries = playlist.playlistEntries;
        //   that.songs = entries.sort(function(a, b) { return a.position - b.position; })
        //                       .map(function(x) { return x.song; });
        //   return;
        // } else {
        //   that.query = playlist.query;
        //   that.genres = playlist.styles;
        // }
      }
      let genreIds = this.genres.map(g => g.id);
      let p = {q: this.query, genres: genreIds.join(',')};
      let omitSongs = [];
      p.bpm = this.searchOptionBpmRestrict && !!this.bpm ? this.bpm : 0;
      p.keys = this.searchOptionKeyRestrict && !!this.song ? this.song.tonicKeys : [];
      p.q += !this.searchOptionTrashedRestrict ? '' : (p.q.length ? ' ' : '') + 'trashed:0';
      omitSongs = !this.searchOptionRepeatRestrict ? [] : this.songTrail.map(e => e.song);
      this.songs = ss.SearchUtil.searchSongs(p.q, p.bpm, p.keys, this.genres, omitSongs, 5); // TODO: this.settings.getInt('songList.limit'));
      // A couple things to note here. First, this timeout will activate when the template repeat has finished loading, which is 99% of the wait time here. Next, I would love to use paper-toast, but it appears that loading the template repeat consumes all the resources that would allow it to animate in. I could set a timeout for the toast animation, but what a waste.
      // setTimeout(function() {
      //   that.$.tooltip.show = false;
      // }, 1);
    // }, 1);
  }
}

window.customElements.define('song-list', SongList);
