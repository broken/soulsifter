import { AlertsMixin } from "./mixin-alerts.js";

class YoutubeClient extends AlertsMixin(Object) {  // TODO show errors

  constructor() {
    super();
    let {google} = require('googleapis');
    this.google = google;
    this.tokenPath = (process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE)
        + '/Library/Application Support/Soul Sifter/.youtube-creds.json';
    // Authorize a client with the loaded credentials, then call the YouTube API.
    this._authorize();
  }

  /**
   * Create an OAuth2 client with the given credentials, and then execute the
   * given callback function.
   *
   * @param {Object} credentials The authorization client credentials.
   * @param {function} callback The callback to call with the authorized client.
   */
  _authorize() {
    let fs = require('fs');
    let OAuth2 = this.google.auth.OAuth2;

    let settings = new ss.SoulSifterSettings();
    let clientId = settings.getString('google.clientId');
    let clientSecret = settings.getString('google.clientSecret');
    let redirectUrl = 'urn:ietf:wg:oauth:2.0:oob';
    this.oauth2Client = new OAuth2(clientId, clientSecret, redirectUrl);

    // Check if we have previously stored a token.
    fs.readFile(this.tokenPath, (err, token) => {
      if (err) {
        this._getNewToken(this.oauth2Client);
      } else {
        // TODO delete token if expired
        this.oauth2Client.credentials = JSON.parse(token);
        this.service = this.google.youtube('v3');
      }
    });
  }

  /**
   * Get and store new token after prompting for user authorization, and then
   * execute the given callback with the authorized OAuth2 client.
   *
   * @param {google.auth.OAuth2} oauth2Client The OAuth2 client to get token for.
   * @param {getEventsCallback} callback The callback to call with the authorized
   *     client.
   */
  _getNewToken(oauth2Client) {
    let authUrl = oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: ['https://www.googleapis.com/auth/youtube']
    });
    console.log('Authorize this app by visiting this url: ', authUrl);
  }

  /**
   * Saves the token we receive.
   */
  saveNewToken(code) {
    this.oauth2Client.getToken(code, (err, token) => {
      if (err) {
        console.log('Error while trying to retrieve access token', err);
        return;
      }
      this.oauth2Client.credentials = token;
      this._storeToken(token);
      callback(oauth2Client);
    }); 
  }

  /**
   * Store token to disk be used in later program executions.
   *
   * @param {Object} token The token to store to disk.
   */
  _storeToken(token) {
    let fs = require('fs');
    fs.writeFile(this.tokenPath, JSON.stringify(token), (err) => {
      if (err) throw err;
      console.log('Token stored to ' + this.tokenPath);
    });
  }

  /**
   * Add a new playlist, save the playlist id, and add the songs.
   */
  async createPlaylist(playlistId) {
    let playlist = ss.Playlist.findById(playlistId);
    try {
      let response = await this._createPlaylist(playlist);
      console.info('Successfully created YouTube playlist ' + playlist.name);
      playlist.youtubeId = response.data.id;
      playlist.update();
    } catch (err) {
      this.addAlert('Unable to create YouTube playlist ' + playlist.name);
      console.error(err);
      return;
    }
    try {
      if (!!playlist.query) {
        let songs = ss.SearchUtil.searchSongs(playlist.query, 0, '', playlist.styles, [], 200, 0, false, 0,
            (msg) => { this.addAlert(msg, 5); });
        for (let i = 0; i < songs.length; ++i) {
          await this._addSongToPlaylist(songs[i], playlist);
        }
      }
    } catch (err) {
      this.addAlert('Unable to add song to YouTube playlist ' + playlist.name);
      console.error(err);
      return;
    }
  }

  async _addSongToPlaylist(song, playlist) {
    if (!song.youtubeId) {
      let response = await this._findSong(song);
      song.youtubeId = response.data.items[0].id.videoId;
      song.update();
    }
    await this._addPlaylistItem(playlist.youtubeId, song.youtubeId);
  }

  async addPlaylistEntry(entryId) {
    let entry = ss.PlaylistEntry.findById(entryId);
    try {
      if (!entry.song.youtubeId) await this.syncSong(entry.song);
      await this._addPlaylistEntry(entry);
    } catch (err) {
      this.addAlert('Unable to add playlist entry ' + entryId);
      console.error(err);
    }
  }

  async syncSong(song) {
    let response = await this._findSong(song);
    song.youtubeId = response.data.items[0].id.videoId;
    song.update();
  }

  async deletePlaylist(ytPlaylistId) {
    try {
      await this._deletePlaylist(ytPlaylistId);
    } catch (err) {
      this.addAlert('Unable to delete YouTube playlist ' + ytPlaylistId);
      console.error(err);
    }
  }

  async updatePlaylistEntries(playlistId) {
    try {
      // get playlist songs
      let playlist = ss.Playlist.findById(playlistId);
      let entries, songs;
      if (!playlist.query) {
        entries = ss.PlaylistEntry.findByPlaylistId(this.playlist.id);
        songs = entries.sort(function(a, b) { return a.position - b.position; })
                       .map(function(x) { return x.song; });
      } else {
        entries = [];
        songs = ss.SearchUtil.searchSongs(playlist.query + ' trashed:0', 0, '', playlist.styles, [], 200);  // todo: err callbck
      }

      // get youtube playlist items
      let items = [];
      let pageToken = undefined;
      do {
        let response = await this._getPlaylistItems(playlist, pageToken);
        for (item of response.data.items) {
          items.push({
            id: item.id,
            videoId: item.snippet.resourceId.videoId,
            position: item.snippet.position
          });
        }
        pageToken = response.data.nextPageToken;
      } while (!!pageToken);

      // filter out dupes with songs
      let x = items.filter(item => !!songs.find(s => s.youtubeId == item.videoId));
      songs = songs.filter(song => !!items.find(i => song.youtubeId == i.videoId));
      items = x;

      // remove items
      for (item in items) {
        await _removePlaylistEntry(item.id);
      }

      // add songs
      for (song of songs) {
        await this._addSongToPlaylist(song, playlist);
      }
    } catch (err) {
      this.addAlert('Unable to update playlist entries for playlist ' + playlistId);
      console.error(err);
    }
  }

  _createPlaylist(playlist) {
    return new Promise((resolve, reject) => {
      this.service.playlists.insert({
        auth: this.oauth2Client,
        part: 'snippet,status',
        resource: {
          snippet: {
            title: playlist.name,
            description: 'managed by SoulSifter'
          },
          status: {
            privacyStatus: 'private'
          }
        }
      }, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }

  _getPlaylistItems(playlist, nextPageToken=undefined) {
    let request = {
        auth: this.oauth2Client,
        part: 'contentDetails,id,snippet,status',
        filter: {
          playlistId: 'playlist.youtubeId'
        },
        maxResults: 20
      };
    if (!!nextPageToken) request.pageToken = nextPageToken;
    return new Promise((resolve, reject) => {
      this.service.playlistItems.list(request, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }

  _findSong(song) {
    return new Promise((resolve, reject) => {
      this.service.search.list({
        auth: this.oauth2Client,
        part: 'snippet',
        q: song.artist + ' ' + song.title,
        type: 'video',
        maxResults: 1
      }, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }

  _addPlaylistItem(playlistId, songId) {
    return new Promise((resolve, reject) => {
      this.service.playlistItems.insert({
        auth: this.oauth2Client,
        part: 'snippet',
        resource: {
          snippet: {
            playlistId: playlistId,
            resourceId: {
              kind: 'youtube#video',
              videoId: songId
            },
          }
        }
      }, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }

  _addPlaylistEntry(entry) {
    return new Promise((resolve, reject) => {
      this.service.playlistItems.insert({
        auth: this.oauth2Client,
        part: 'snippet',
        resource: {
          snippet: {
            playlistId: entry.playlist.youtubeId,
            resourceId: {
              kind: 'youtube#video',
              videoId: entry.song.youtubeId
            },
            position: entry.position
          }
        }
      }, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }

  _removePlaylistEntry(itemId) {
    return new Promise((resolve, reject) => {
      this.service.playlistItems.delete({
        auth: this.oauth2Client,
        resource: {
          id: itemId
        }
      }, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }

  _deletePlaylist(playlistId) {
    return new Promise((resolve, reject) => {
      this.service.playlists.delete({
        auth: this.oauth2Client,
        id: playlistId
      }, (err, response) => {
        if (err) reject(err);
        else resolve(response);
      });
    });
  }




  /**
   * Lists the names and IDs of up to 10 files.
   *
   * @param {google.auth.OAuth2} auth An authorized OAuth2 client.
   */
  getChannel() {
    let service = this.google.youtube('v3');
    this.service = service;
    service.channels.list({
      auth: this.oauth2Client,
      part: 'snippet,contentDetails,statistics',
      mine: true
    }, (err, response) => {
      if (err) {
        console.log('The API returned an error: ' + err);
        return;
      }
      let channels = response.data.items;
      if (channels.length == 0) {
        console.log('No channel found.');
      } else {
        console.log('This channel\'s ID is %s. Its title is \'%s\', and ' +
                    'it has %s views.',
                    channels[0].id,
                    channels[0].snippet.title,
                    channels[0].statistics.viewCount);
      }
    });
  }

  /**
   * Callback returns err, streamUrl
   */
  async getStreamUrl(gmid) {
    return;
    return new Promise((resolve, reject) => {
      let callback = (err, url) => {
        if (err) reject(err);
        else resolve(url);
      }
      this.init(() => this.playMusic.getStreamUrl(gmid, callback));
    });
  }

};

if (!window.yt) window.yt = new YoutubeClient();
