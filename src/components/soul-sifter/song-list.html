<link href="../polymer/polymer.html" rel="import">

<link href="../iron-selector/iron-selector.html" rel="import">
<link href="../iron-signals/iron-signals.html" rel="import">
<link href="../core-tooltip/core-tooltip.html" rel="import">

<link href="song-list-item.html" rel="import">
<link href="ss-global-behavior.html" rel="import">


<dom-module id="song-list">
  <style is="custom-style">
    core-tooltip {
      position: absolute;
      left: 50%;
    }

    .song {
      height: 20px;
      padding-left: 5px;
    }
  </style>
  <template>
    <iron-signals on-iron-signal-search="search"></iron-signals>

    <core-tooltip id="tooltip" label="Searching..." noarrow position top></core-tooltip>
    <!-- due to multiple bugs in iron-selector, we listen for the iron-activate event -->
    <iron-selector on-iron-activate="_selectedSongChanged">
      <template is="dom-repeat" items="{{songs}}">
        <song-list-item song="{{item}}"></song-list-item>
      </template>
    </iron-selector>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'song-list',

    behaviors: [
      GlobalBehavior
    ],

    properties: {
      query: {
        type: String,
        observer: '_queryChanged'
      },
      songTrail: {
        type: Array,
        value: function() { return []; }
      },
      songs: {
        type: Array,
        value: function() { return []; }
      },
      genres: {
        type: Array,
        value: function() { return []; }
      },
      settings: {
        type: Object,
        value: function() { return new ss.SoulSifterSettings(); },
        readOnly: true
      },
      searchOptionBpmRestrict: Boolean,
      searchOptionKeyRestrict: Boolean,
      searchOptionTrashedRestrict: Boolean,
    },

    observers: [
      '_globalBpmChanged(global.bpm)',
      '_globalPlaylistChanged(global.playlist)'
    ],

    attached: function() {
      // https://www.polymer-project.org/1.0/docs/migration.html#domready
      this.async(function() {
        this.search();
      }.bind(this));
    },

    _globalBpmChanged: function(bpm) {
      if (this.searchOptionBpmRestrict) this.search();
    },

    _globalPlaylistChanged: function(playlist) {
      if (!!playlist) this.search();
    },

    _selectedSongChanged: function(e) {
      this.set('global.song', e.detail.item.song);
    },

    _queryChanged: function(newValue, oldValue) {
      // only search if it's not actively being changed
      setTimeout(function(self, query) {
        return function() {
          if (self.query == query) {
            self.search();
          }
        };
      }(this, this.query), 750);
    },

    search: function(e, detail, sender) {
      this.$.tooltip.show = true;
      var that = this;
      // give the tooltip a chance to show
      setTimeout(function() {
        if (!!that.global.playlist) {
          var playlist = that.global.playlist;
          if (!playlist.query) {
            var entries = playlist.playlistEntries;
            that.songs = entries.sort(function(a, b) { return a.position - b.position; })
                                .map(function(x) { return x.song; });
            return;
          } else {
            that.query = playlist.query;
            that.genres = playlist.styles;
          }
        }
        var genreIds = that.genres.map(function(g) { return g.id; });
        var p = {q: that.query, genres: genreIds.join(','), min: 0, max: 0};
        var omitSongs = [];
        if (that.searchOptionBpmRestrict && that.global.bpm) {
          var pitchPctMax = 8;
          p.min  = that.global.bpm * (100 - pitchPctMax) / 100;
          p.max = that.global.bpm * (100 + pitchPctMax) / 100;
        }
        if (that.searchOptionKeyRestrict && that.global.song) {
          p.keys = that.global.song.tonicKeys;
        } else {
          p.keys = [];
        }
        if (that.searchOptionTrashedRestrict) {
          p.q += " trashed:0";
        }
        if (true) {
          omitSongs = that.songTrail.map(function(e) { return e.song; });
        }
        that.songs = ss.SearchUtil.searchSongs(p.q, p.min, p.max, p.keys, that.genres, omitSongs, that.settings.getInt('songList.limit'));
        // A couple things to note here. First, this timeout will activate when the template repeat has finished loading, which is 99% of the wait time here. Next, I would love to use paper-toast, but it appears that loading the template repeat consumes all the resources that would allow it to animate in. I could set a timeout for the toast animation, but what a waste.
        setTimeout(function() {
          that.$.tooltip.show = false;
        }, 1);
      }, 1);
    },

  });
</script>
