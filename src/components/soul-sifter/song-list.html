<link href="../polymer/polymer.html" rel="import">

<link href="../core-ajax/core-ajax.html" rel="import">
<link href="../core-selector/core-selector.html" rel="import">
<link href="../core-signals/core-signals.html" rel="import">
<link href="../core-style/core-style.html" rel="import">
<link href="../core-tooltip/core-tooltip.html" rel="import">

<link href="global-state.html" rel="import">
<link href="song-list-item.html" rel="import">
<link href="themes.html" rel="import">


<polymer-element name="song-list" attributes="query">

  <template>
    <link href="song-list.css" rel="stylesheet">
    <core-style ref="main"></core-style>

    <global-state values="{{global}}"></global-state>
    <core-signals on-core-signal-genres-changed="{{genresChanged}}"
                          on-core-signal-search="{{searchAction}}"></core-signals>

    <core-selector selected="{{selectedRow}}" activateEvent="click">
      <template repeat="{{s in songs}}">
        <song-list-item song="{{s}}"></song-list-item>
      </template>
    </core-selector>
    </core-list>
  </template>

  <script>
    Polymer('song-list', {

      observe: {
        'global.bpm': 'globalBpmChanged'
      },

      created: function() {
        // init & hint lists & objects
        this.songs = [];
        this.genres = [];
      },

      domReady: function() {
        //this.$.core_tooltip.show = false;
        this.songs = ss.SearchUtil.searchSongs('', 0, 0, '', [], 200);
        /*if (response.response.song) {
          this.songs = response.response.song;
        } else {
          this.songs = [];
        }*/
      },

      globalBpmChanged: function(oldValue, newValue) {
        var pitchPctMax = 8;
        this.minBpm = this.global.bpm * (100 - pitchPctMax) / 100;
        this.maxBpm = this.global.bpm * (100 + pitchPctMax) / 100;
        this.searchAction();
      },

      genresChanged: function(e, detail, sender) {
        this.genres = detail;
      },

      selectedRowChanged: function(e, detail, sender) {
        var s = this.songs[detail];
        this.global.song = s;
      },

      queryChanged: function(e, detail, sender) {
        // only search if it's not actively being changed
        setTimeout(function(self, query, e, detail, sender) {
          return function() {
            if (self.query == query) {
              self.searchAction(e, detail, sender);
            }
          };
        }(this, this.query, e, detail, sender), 750);
      },

      searchAction: function(e, detail, sender) {
        if (detail && detail.playlist) {
          var entries = detail.playlist.playlistEntries;
          this.songs = entries.sort(function(a, b) { return a.position - b.position; })
                              .map(function(x) { return x.song; });
        } else {
          //this.$.core_tooltip.show = true;
          var genreIds = this.genres.map(function(g) { return g.id; });
          var p = {q: this.query, genres: genreIds.join(','), min: 0, max: 0};
          if (this.minBpm) p.min = this.minBpm;
          if (this.maxBpm) p.max = this.maxBpm;
          if (this.global.song) p.key = this.global.song.tonicKey;  // todo
          this.songs = ss.SearchUtil.searchSongs(p.q, p.min, p.max, p.key, this.genres, 200);
          //this.$.core_tooltip.show = false;
        }
      },

      /*genresChanged: function(e, detail, sender) {
        this.genres = detail;
      },

      queryChanged: function(e, detail, sender) {
        this.$.core_tooltip.show = true;
        var genreIds = this.genres.map(function(g) { return g.id; });
        var p = {q: this.query, min: this.minBpm, max: this.maxBpm, key: this.selectedSong.tonicKey, genres: genreIds.join(',')};
        this.ajaxParams = JSON.stringify(p);
      }*/
    });
  </script>
</polymer-element>