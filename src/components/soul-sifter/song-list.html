<link href="../polymer/polymer.html" rel="import">

<link href="../iron-selector/iron-selector.html" rel="import">
<link href="../iron-signals/iron-signals.html" rel="import">
<link href="../core-tooltip/core-tooltip.html" rel="import">

<link href="global-state.html" rel="import">
<link href="song-list-item.html" rel="import">
<link href="themes.html" rel="import">


<dom-module id="song-list">
  <link href="song-list.css" rel="import" type="css">
  <template>
    <global-state values="{{global}}"></global-state>
    <iron-signals on-iron-signal-genres-changed="{{genresChanged}}"
                          on-iron-signal-search="{{searchAction}}"></iron-signals>

    <core-tooltip id="tooltip" label="Searching..." noarrow position top></core-tooltip>
    <iron-selector selected="{{selectedRow}}" activateEvent="click" id="selector">
      <template is="dom-repeat" items="{{songs}}">
        <song-list-item song="{{item}}"></song-list-item>
      </template>
    </iron-selector>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'song-list',

    properties: {
      query: {
        type: String,
        observer: 'queryChanged'
      },
      djSearch: Boolean,
      songTrail: Array
    },

    observers: [
      'globalBpmChanged(global.bpm)'
    ],

    created: function() {
      // init & hint lists & objects
      this.songs = [];
      this.genres = [];
      this.songTrail = [];
      this.settings = new ss.SoulSifterSettings();
    },

    domReady: function() {
      this.searchAction();
    },

    globalBpmChanged: function(newValue) {
      if (this.djSearch) this.searchAction();
    },

    genresChanged: function(e, detail, sender) {
      this.genres = detail;
    },

    selectedRowChanged: function(e, detail, sender) {
      var selectedRowIndex = detail;
      if (selectedRowIndex != -1) {
        var s = this.songs[selectedRowIndex];
        this.global.song = s;
      }
    },

    queryChanged: function(newValue, oldValue) {
      // only search if it's not actively being changed
      setTimeout(function(self, query) {
        return function() {
          if (self.query == query) {
            self.searchAction();
          }
        };
      }(this, this.query), 750);
    },

    searchAction: function(e, detail, sender) {
      this.$.tooltip.show = true;
      var that = this;
      // give the tooltip a chance to show
      setTimeout(function() {
        if (detail && detail.playlist) {
          var entries = detail.playlist.playlistEntries;
          that.songs = entries.sort(function(a, b) { return a.position - b.position; })
                              .map(function(x) { return x.song; });
        } else {
          var genreIds = that.genres.map(function(g) { return g.id; });
          var p = {q: that.query, genres: genreIds.join(','), min: 0, max: 0};
          var omitSongs = [];
          if (that.djSearch) {
            if (that.global.bpm) {
              var pitchPctMax = 8;
              p.min  = that.global.bpm * (100 - pitchPctMax) / 100;
              p.max = that.global.bpm * (100 + pitchPctMax) / 100;
            }
            if (that.global.song) p.key = that.global.song.tonicKey;  // todo
            omitSongs = that.songTrail.map(function(e) { return e.song; });
          }
          that.songs = ss.SearchUtil.searchSongs(p.q, p.min, p.max, p.key, that.genres, omitSongs, that.settings.getInt('songList.limit'));
        }
        // clear the row selection
        that.$.selector.selected = -1;
        // A couple things to note here. First, this timeout will activate when the template repeat has finished loading, which is 99% of the wait time here. Next, I would love to use paper-toast, but it appears that loading the template repeat consumes all the resources that would allow it to animate in. I could set a timeout for the toast animation, but what a waste.
        setTimeout(function() {
          that.$.tooltip.show = false;
        }, 1);
      }, 1);
    },

  });
</script>
