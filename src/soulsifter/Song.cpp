//
//  Song.cpp
//  soul-sifter
//
//  Created by Robby Neale
//  Generated by generate_model.rb
//

#include "Song.h"

#include <cmath>
#include <string>

#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>

#include <cppconn/connection.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include <cppconn/resultset.h>
#include <cppconn/exception.h>
#include <cppconn/warning.h>

#include "MysqlAccess.h"
#include "DTVectorUtil.h"

using namespace std;

namespace dogatech {
namespace soulsifter {

# pragma mark initialization

    Song::Song() :
    id(0),
    artist(),
    track(),
    title(),
    remixer(),
    featuring(),
    filepath(),
    rating(0),
    dateAdded(NULL),
    bpm(),
    tonicKeys(),
    tonicKey(),
    comments(),
    trashed(false),
    lowQuality(false),
    reSongId(0),
    reSong(NULL),
    albumId(0),
    album(NULL),
    albumPartId(0),
    albumPart(NULL),
    styleIds(),
    styles() {
    }

    Song::Song(const Song& song) :
    id(song.getId()),
    artist(song.getArtist()),
    track(song.getTrack()),
    title(song.getTitle()),
    remixer(song.getRemixer()),
    featuring(song.getFeaturing()),
    filepath(song.getFilepath()),
    rating(song.getRating()),
    dateAdded(song.getDateAdded()),
    bpm(song.getBpm()),
    tonicKeys(song.getTonicKeys()),
    tonicKey(song.getTonicKey()),
    comments(song.getComments()),
    trashed(song.getTrashed()),
    lowQuality(song.getLowQuality()),
    reSongId(song.getRESongId()),
    reSong(NULL),
    albumId(song.getAlbumId()),
    album(NULL),
    albumPartId(song.getAlbumPartId()),
    albumPart(NULL),
    styleIds(song.getStyleIds()),
    styles() {
        if (song.getRESong()) setRESong(*song.getRESong());
        if (song.getAlbum()) setAlbum(*song.getAlbum());
        if (song.getAlbumPart()) setAlbumPart(*song.getAlbumPart());
    }

    void Song::operator=(const Song& song) {
        id = song.getId();
        artist = song.getArtist();
        track = song.getTrack();
        title = song.getTitle();
        remixer = song.getRemixer();
        featuring = song.getFeaturing();
        filepath = song.getFilepath();
        rating = song.getRating();
        dateAdded = song.getDateAdded();
        bpm = song.getBpm();
        tonicKeys = song.getTonicKeys();
        tonicKey = song.getTonicKey();
        comments = song.getComments();
        trashed = song.getTrashed();
        lowQuality = song.getLowQuality();
        reSongId = song.getRESongId();
        reSong = NULL;
        albumId = song.getAlbumId();
        album = NULL;
        albumPartId = song.getAlbumPartId();
        albumPart = NULL;
        styleIds = song.getStyleIds();
        deleteVectorPointers(&styles);
    }

    Song::~Song() {
        delete reSong;
        reSong = NULL;
        delete album;
        album = NULL;
        delete albumPart;
        albumPart = NULL;
        while (!styles.empty()) delete styles.back(), styles.pop_back();
    }

    void Song::clear() {
        id = 0;
        artist.clear();
        track.clear();
        title.clear();
        remixer.clear();
        featuring.clear();
        filepath.clear();
        rating = 0;
        dateAdded = 0;
        bpm.clear();
        tonicKeys.clear();
        tonicKey.clear();
        comments.clear();
        trashed = false;
        lowQuality = false;
        reSongId = 0;
        delete reSong;
        reSong = NULL;
        albumId = 0;
        delete album;
        album = NULL;
        albumPartId = 0;
        delete albumPart;
        albumPart = NULL;
        styleIds.clear();
        deleteVectorPointers(&styles);
    }

# pragma mark static methods

    void Song::populateFields(const sql::ResultSet* rs, Song* song) {
        song->setId(rs->getInt("id"));
        song->setArtist(rs->getString("artist"));
        song->setTrack(rs->getString("track"));
        song->setTitle(rs->getString("title"));
        song->setRemixer(rs->getString("remixer"));
        song->setFeaturing(rs->getString("featuring"));
        song->setFilepath(rs->getString("filepath"));
        song->setRating(rs->getInt("rating"));
        song->setDateAdded(timeFromString(rs->getString("dateAdded")));
        song->setBpm(rs->getString("bpm"));
        song->setTonicKey(rs->getString("tonicKey"));
        song->setComments(rs->getString("comments"));
        song->setTrashed(rs->getBoolean("trashed"));
        song->setLowQuality(rs->getBoolean("lowQuality"));
        song->setRESongId(rs->getInt("reSongId"));
        song->setAlbumId(rs->getInt("albumId"));
        if (rs->isNull("albumPartId")) song->setAlbumPartId(0);
        else song->setAlbumPartId(rs->getInt("albumPartId"));
        if (!rs->isNull("styleIds")) {
            string csv = rs->getString("styleIds");
            istringstream iss(csv);
            string id;
            while (getline(iss, id, ',')) {
              song->styleIds.push_back(atoi(id.c_str()));
            }
        }
        if (!rs->isNull("tonicKeys")) {
            string dbSet = rs->getString("tonicKeys");
            boost::split(song->tonicKeys, dbSet, boost::is_any_of(","));
        }
    }

    Song* Song::findById(int id) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select *, group_concat(styles.styleId) as styleIds from Songs left outer join SongStyles styles on Songs.id = styles.songId where id = ? group by Songs.id");
            ps->setInt(1, id);
            sql::ResultSet *rs = ps->executeQuery();
            Song *song = NULL;
            if (rs->next()) {
                song = new Song();
                populateFields(rs, song);
            }
            rs->close();
            delete rs;

            return song;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    Song* Song::findByFilepath(const string& filepath) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select *, group_concat(styles.styleId) as styleIds from Songs left outer join SongStyles styles on Songs.id = styles.songId where filepath = ? group by Songs.id");
            ps->setString(1, filepath);
            sql::ResultSet *rs = ps->executeQuery();
            Song *song = NULL;
            if (rs->next()) {
                song = new Song();
                populateFields(rs, song);
            }
            rs->close();
            delete rs;

            return song;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    Song* Song::findByRESongId(int reSongId) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select *, group_concat(styles.styleId) as styleIds from Songs left outer join SongStyles styles on Songs.id = styles.songId where reSongId = ? group by Songs.id");
            ps->setInt(1, reSongId);
            sql::ResultSet *rs = ps->executeQuery();
            Song *song = NULL;
            if (rs->next()) {
                song = new Song();
                populateFields(rs, song);
            }
            rs->close();
            delete rs;

            return song;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    ResultSetIterator<Song>* Song::findAll() {
        sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select *, group_concat(styles.styleId) as styleIds from Songs left outer join SongStyles styles on Songs.id = styles.songId group by Songs.id");
        sql::ResultSet *rs = ps->executeQuery();
        ResultSetIterator<Song> *dtrs = new ResultSetIterator<Song>(rs);
        return dtrs;
    }

# pragma mark persistence

    int Song::update() {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("update Songs set artist=?, track=?, title=?, remixer=?, featuring=?, filepath=?, rating=?, dateAdded=?, bpm=?, tonicKeys=?, tonicKey=?, comments=?, trashed=?, lowQuality=?, reSongId=?, albumId=?, albumPartId=? where id=?");
            ps->setString(1, artist);
            ps->setString(2, track);
            ps->setString(3, title);
            ps->setString(4, remixer);
            ps->setString(5, featuring);
            ps->setString(6, filepath);
            ps->setInt(7, rating);
            ps->setString(8, stringFromTime(dateAdded));
            ps->setString(9, bpm);
            ps->setString(10, setToCsv(tonicKeys));
            ps->setString(11, tonicKey);
            ps->setString(12, comments);
            ps->setBoolean(13, trashed);
            ps->setBoolean(14, lowQuality);
            ps->setInt(15, reSongId);
            ps->setInt(16, albumId);
            if (albumPartId > 0) ps->setInt(17, albumPartId);
            else ps->setNull(17, sql::DataType::INTEGER);
            ps->setInt(18, id);
            int result = ps->executeUpdate();
            if (!styleIds.empty()) {
                stringstream ss("insert ignore into SongStyles (songId, styleId) values (?, ?)");
                for (int i = 1; i < styleIds.size(); ++i) {
                    ss << ", (?, ?)";
                }
                ps = MysqlAccess::getInstance().getPreparedStatement(ss.str());
                for (int i = 0; i < styleIds.size(); ++i) {
                    ps->setInt(i * 2 + 1, id);
                    ps->setInt(i * 2 + 2, styleIds[i]);
                }
                ps->executeUpdate();
                ss.clear();
                ss << "delete from SongStyles where songId = ? and styleId not in (?";
                for (int i = 1; i < styleIds.size(); ++i) {
                    ss << ", ?";
                }
                ss << ")";
                ps = MysqlAccess::getInstance().getPreparedStatement(ss.str());
                ps->setInt(1, id);
                for (int i = 0; i < styleIds.size(); ++i) {
                    ps->setInt(i + 2, styleIds[i]);
                }
                ps->executeUpdate();
            } else {
                ps = MysqlAccess::getInstance().getPreparedStatement("delete from SongStyles where songId = ?");
                ps->setInt(1, id);
                ps->executeUpdate();
            }
            return result;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    int Song::save() {
        try {
            if (reSong && (!reSong->getId() || !RESong::findById(reSong->getId()))) {
                if (reSong->save()) {
                    if (reSong->getId()) {
                        reSongId = reSong->getId();
                    } else {
                        reSongId = MysqlAccess::getInstance().getLastInsertId();
                        reSong->setId(reSongId);
                    }
                } else {
                    cerr << "Unable to save reSong" << endl;
                }
            }
            if (album && (!album->getId() || !Album::findById(album->getId()))) {
                if (album->save()) {
                    if (album->getId()) {
                        albumId = album->getId();
                    } else {
                        albumId = MysqlAccess::getInstance().getLastInsertId();
                        album->setId(albumId);
                    }
                } else {
                    cerr << "Unable to save album" << endl;
                }
            }
            if (albumPart && (!albumPart->getId() || !AlbumPart::findById(albumPart->getId()))) {
                if (albumPart->save()) {
                    if (albumPart->getId()) {
                        albumPartId = albumPart->getId();
                    } else {
                        albumPartId = MysqlAccess::getInstance().getLastInsertId();
                        albumPart->setId(albumPartId);
                    }
                } else {
                    cerr << "Unable to save albumPart" << endl;
                }
            }
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("insert into Songs (artist, track, title, remixer, featuring, filepath, rating, dateAdded, bpm, tonicKeys, tonicKey, comments, trashed, lowQuality, reSongId, albumId, albumPartId) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
            ps->setString(1, artist);
            ps->setString(2, track);
            ps->setString(3, title);
            ps->setString(4, remixer);
            ps->setString(5, featuring);
            ps->setString(6, filepath);
            ps->setInt(7, rating);
            ps->setString(8, stringFromTime(dateAdded));
            ps->setString(9, bpm);
            ps->setString(10, setToCsv(tonicKeys));
            ps->setString(11, tonicKey);
            ps->setString(12, comments);
            ps->setBoolean(13, trashed);
            ps->setBoolean(14, lowQuality);
            ps->setInt(15, reSongId);
            ps->setInt(16, albumId);
            if (albumPartId > 0) ps->setInt(17, albumPartId);
            else ps->setNull(17, sql::DataType::INTEGER);
            int saved = ps->executeUpdate();
            if (!saved) {
                cerr << "Not able to save song" << endl;
                return saved;
            } else {
                id = MysqlAccess::getInstance().getLastInsertId();
                if (id == 0) {
                    cerr << "Inserted song, but unable to retreive inserted ID." << endl;
                    return saved;
                }
                ps = MysqlAccess::getInstance().getPreparedStatement("insert ignore into SongStyles (songId, styleId) values (?, ?)");
                for (vector<int>::iterator it = styleIds.begin(); it != styleIds.end(); ++it) {
                    ps->setInt(1, id);
                    ps->setInt(2, *it);
                    if (!ps->executeUpdate()) {
                        cerr << "Did not save style for song " << id << endl;
                    }
                }
                return saved;
            }
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }


# pragma mark accessors

    const int Song::getId() const { return id; }
    void Song::setId(const int id) { this->id = id; }

    const string& Song::getArtist() const { return artist; }
    void Song::setArtist(const string& artist) { this->artist = artist; }

    const string& Song::getTrack() const { return track; }
    void Song::setTrack(const string& track) { this->track = track; }

    const string& Song::getTitle() const { return title; }
    void Song::setTitle(const string& title) { this->title = title; }

    const string& Song::getRemixer() const { return remixer; }
    void Song::setRemixer(const string& remixer) { this->remixer = remixer; }

    const string& Song::getFeaturing() const { return featuring; }
    void Song::setFeaturing(const string& featuring) { this->featuring = featuring; }

    const string& Song::getFilepath() const { return filepath; }
    void Song::setFilepath(const string& filepath) { this->filepath = filepath; }

    const int Song::getRating() const { return rating; }
    void Song::setRating(const int rating) { this->rating = rating; }

    const time_t Song::getDateAdded() const { return dateAdded; }
    void Song::setDateAdded(const time_t dateAdded) { this->dateAdded = dateAdded; }

    const string& Song::getBpm() const { return bpm; }
    void Song::setBpm(const string& bpm) { this->bpm = bpm; }

    const set<string>& Song::getTonicKeys() const {
        return tonicKeys;
    }
    void Song::setTonicKeys(const set<string>& tonicKeys) {
        this->tonicKeys = tonicKeys;
    }
    void Song::addTonicKey(const string& tonicKey) {
        this->tonicKeys.insert(tonicKey);
    }
    void Song::removeTonicKey(const string& tonicKey) {
        this->tonicKeys.erase(tonicKey);
    }

    const string& Song::getTonicKey() const { return tonicKey; }
    void Song::setTonicKey(const string& tonicKey) { this->tonicKey = tonicKey; }

    const string& Song::getComments() const { return comments; }
    void Song::setComments(const string& comments) { this->comments = comments; }

    const bool Song::getTrashed() const { return trashed; }
    void Song::setTrashed(const bool trashed) { this->trashed = trashed; }

    const bool Song::getLowQuality() const { return lowQuality; }
    void Song::setLowQuality(const bool lowQuality) { this->lowQuality = lowQuality; }

    const int Song::getRESongId() const { return reSongId; }
    void Song::setRESongId(const int reSongId) {
        this->reSongId = reSongId;
        delete reSong;
        reSong = NULL;
    }

    RESong* Song::getRESong() const {
        if (!reSong && reSongId)
            return RESong::findById(reSongId);
        return reSong;
    }
    void Song::setRESong(const RESong& reSong) {
        this->reSongId = reSong.getId();
        delete this->reSong;
        this->reSong = new RESong(reSong);
    }
    void Song::setRESong(RESong* reSong) {
        this->reSongId = reSong->getId();
        delete this->reSong;
        this->reSong = reSong;
    }

    const int Song::getAlbumId() const { return albumId; }
    void Song::setAlbumId(const int albumId) {
        this->albumId = albumId;
        delete album;
        album = NULL;
    }

    Album* Song::getAlbum() const {
        if (!album && albumId)
            return Album::findById(albumId);
        return album;
    }
    void Song::setAlbum(const Album& album) {
        this->albumId = album.getId();
        delete this->album;
        this->album = new Album(album);
    }
    void Song::setAlbum(Album* album) {
        this->albumId = album->getId();
        delete this->album;
        this->album = album;
    }

    const int Song::getAlbumPartId() const { return albumPartId; }
    void Song::setAlbumPartId(const int albumPartId) {
        this->albumPartId = albumPartId;
        delete albumPart;
        albumPart = NULL;
    }

    AlbumPart* Song::getAlbumPart() const {
        if (!albumPart && albumPartId)
            return AlbumPart::findById(albumPartId);
        return albumPart;
    }
    void Song::setAlbumPart(const AlbumPart& albumPart) {
        this->albumPartId = albumPart.getId();
        delete this->albumPart;
        this->albumPart = new AlbumPart(albumPart);
    }
    void Song::setAlbumPart(AlbumPart* albumPart) {
        this->albumPartId = albumPart->getId();
        delete this->albumPart;
        this->albumPart = albumPart;
    }

    const vector<int>& Song::getStyleIds() const { return styleIds; }
    void Song::setStyleIds(const vector<int>& styleIds) {
        while (!styles.empty()) delete styles.back(), styles.pop_back();
        this->styleIds.clear();
        this->styleIds = styleIds;
    }

    const vector<Style*>& Song::getStyles() {
        if (styles.empty() && !styleIds.empty()) {
            for (vector<int>::const_iterator it = styleIds.begin(); it != styleIds.end(); ++it) {
                styles.push_back(Style::findById(*it));
            }
        }
        return styles;
    }
    void Song::setStyles(const vector<Style*>& styles) {
        deleteVectorPointers<Style*>(&this->styles);
        this->styles = styles;
        this->styleIds.clear();
        for (vector<Style*>::const_iterator it = styles.begin(); it != styles.end(); ++it) {
            this->styleIds.push_back((*it)->getId());
        }
    }

}
}
