//
//  Song.cpp
//  soul-sifter
//
//  Created by Robby Neale
//  Generated by generate_model.rb
//

#include "Song.h"

#include <cmath>
#include <string>

#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>

#include <cppconn/connection.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include <cppconn/resultset.h>
#include <cppconn/exception.h>
#include <cppconn/warning.h>

#include "MysqlAccess.h"
#include "DTVectorUtil.h"

using namespace std;

namespace dogatech {
namespace soulsifter {

# pragma mark initialization

    Song::Song() :
    id(0),
    artist(),
    track(),
    title(),
    remixer(),
    featuring(),
    filepath(),
    rating(0),
    dateAdded(NULL),
    bpm(),
    tonicKeys(),
    comments(),
    trashed(false),
    lowQuality(false),
    reSongId(0),
    reSong(NULL),
    albumId(0),
    album(NULL),
    albumPartId(0),
    albumPart(NULL),
    styles(),
    stylesIds() {
    }

    Song::Song(const Song& song) :
    id(song.getId()),
    artist(song.getArtist()),
    track(song.getTrack()),
    title(song.getTitle()),
    remixer(song.getRemixer()),
    featuring(song.getFeaturing()),
    filepath(song.getFilepath()),
    rating(song.getRating()),
    dateAdded(song.getDateAdded()),
    bpm(song.getBpm()),
    tonicKeys(song.getTonicKeys()),
    comments(song.getComments()),
    trashed(song.getTrashed()),
    lowQuality(song.getLowQuality()),
    reSongId(song.getRESongId()),
    reSong(NULL),
    albumId(song.getAlbumId()),
    album(NULL),
    albumPartId(song.getAlbumPartId()),
    albumPart(NULL),
    styles(),
    stylesIds(song.stylesIds) {
        if (song.getRESong()) setRESong(*song.getRESong());
        if (song.getAlbum()) setAlbum(*song.getAlbum());
        if (song.getAlbumPart()) setAlbumPart(*song.getAlbumPart());
    }

    void Song::operator=(const Song& song) {
        id = song.getId();
        artist = song.getArtist();
        track = song.getTrack();
        title = song.getTitle();
        remixer = song.getRemixer();
        featuring = song.getFeaturing();
        filepath = song.getFilepath();
        rating = song.getRating();
        dateAdded = song.getDateAdded();
        bpm = song.getBpm();
        tonicKeys = song.getTonicKeys();
        comments = song.getComments();
        trashed = song.getTrashed();
        lowQuality = song.getLowQuality();
        reSongId = song.getRESongId();
        reSong = NULL;
        albumId = song.getAlbumId();
        album = NULL;
        albumPartId = song.getAlbumPartId();
        albumPart = NULL;
        stylesIds = song.stylesIds;
        deleteVectorPointers(&styles);
    }

    Song::~Song() {
        delete reSong;
        reSong = NULL;
        delete album;
        album = NULL;
        delete albumPart;
        albumPart = NULL;
        while (!styles.empty()) delete styles.back(), styles.pop_back();
    }

    void Song::clear() {
        id = 0;
        artist.clear();
        track.clear();
        title.clear();
        remixer.clear();
        featuring.clear();
        filepath.clear();
        rating = 0;
        dateAdded = 0;
        bpm.clear();
        tonicKeys.clear();
        comments.clear();
        trashed = false;
        lowQuality = false;
        reSongId = 0;
        delete reSong;
        reSong = NULL;
        albumId = 0;
        delete album;
        album = NULL;
        albumPartId = 0;
        delete albumPart;
        albumPart = NULL;
        deleteVectorPointers(&styles);
        stylesIds.clear();
    }

# pragma mark static methods

    void Song::populateFields(const sql::ResultSet* rs, Song* song) {
        song->setId(rs->getInt("id"));
        song->setArtist(rs->getString("artist"));
        song->setTrack(rs->getString("track"));
        song->setTitle(rs->getString("title"));
        song->setRemixer(rs->getString("remixer"));
        song->setFeaturing(rs->getString("featuring"));
        song->setFilepath(rs->getString("filepath"));
        song->setRating(rs->getInt("rating"));
        song->setDateAdded(timeFromString(rs->getString("dateAdded")));
        song->setBpm(rs->getString("bpm"));
        song->setComments(rs->getString("comments"));
        song->setTrashed(rs->getBoolean("trashed"));
        song->setLowQuality(rs->getBoolean("lowQuality"));
        song->setRESongId(rs->getInt("reSongId"));
        song->setAlbumId(rs->getInt("albumId"));
        if (rs->isNull("albumPartId")) song->setAlbumPartId(0);
        else song->setAlbumPartId(rs->getInt("albumPartId"));
        populateStylesIds(song);
        if (!rs->isNull("tonicKeys")) {
            string dbSet = rs->getString("tonicKeys");
            boost::split(song->tonicKeys, dbSet, boost::is_any_of(","));
        }
    }

    void Song::populateStylesIds(Song* song) {
        sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select styleId from SongStyles where songId = ?");
        ps->setInt(1, song->getId());
        sql::ResultSet *rs = ps->executeQuery();
        while (rs->next()) {
            song->stylesIds.push_back(rs->getInt(1));
        }
        rs->close();
        delete rs;
    }

    Song* Song::findById(int id) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Songs where id = ?");
            ps->setInt(1, id);
            sql::ResultSet *rs = ps->executeQuery();
            Song *song = NULL;
            if (rs->next()) {
                song = new Song();
                populateFields(rs, song);
            }
            rs->close();
            delete rs;

            return song;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    Song* Song::findByFilepath(const string& filepath) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Songs where filepath = ?");
            ps->setString(1, filepath);
            sql::ResultSet *rs = ps->executeQuery();
            Song *song = NULL;
            if (rs->next()) {
                song = new Song();
                populateFields(rs, song);
            }
            rs->close();
            delete rs;

            return song;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    Song* Song::findByRESongId(int reSongId) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Songs where reSongId = ?");
            ps->setInt(1, reSongId);
            sql::ResultSet *rs = ps->executeQuery();
            Song *song = NULL;
            if (rs->next()) {
                song = new Song();
                populateFields(rs, song);
            }
            rs->close();
            delete rs;

            return song;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    ResultSetIterator<Song>* Song::findAll() {
        sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Songs");
        sql::ResultSet *rs = ps->executeQuery();
        ResultSetIterator<Song> *dtrs = new ResultSetIterator<Song>(rs);
        return dtrs;
    }

# pragma mark persistence

    bool Song::sync() {
        Song* song = findById(id);
        if (!song) song = findByRESongId(reSongId);
        if (!song) {
            return true;
        }

        // check fields
        bool needsUpdate = false;
        boost::regex decimal("(-?\\d+)\\.?\\d*");
        boost::smatch match1;
        boost::smatch match2;
        if (id != song->getId()) {
            if (id) {
                cout << "updating song " << id << " id from " << song->getId() << " to " << id << endl;
                needsUpdate = true;
            } else {
                id = song->getId();
            }
        }
        if (artist.compare(song->getArtist())  && (!boost::regex_match(artist, match1, decimal) || !boost::regex_match(song->getArtist(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!artist.empty()) {
                cout << "updating song " << id << " artist from " << song->getArtist() << " to " << artist << endl;
                needsUpdate = true;
            } else {
                artist = song->getArtist();
            }
        }
        if (track.compare(song->getTrack())  && (!boost::regex_match(track, match1, decimal) || !boost::regex_match(song->getTrack(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!track.empty()) {
                cout << "updating song " << id << " track from " << song->getTrack() << " to " << track << endl;
                needsUpdate = true;
            } else {
                track = song->getTrack();
            }
        }
        if (title.compare(song->getTitle())  && (!boost::regex_match(title, match1, decimal) || !boost::regex_match(song->getTitle(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!title.empty()) {
                cout << "updating song " << id << " title from " << song->getTitle() << " to " << title << endl;
                needsUpdate = true;
            } else {
                title = song->getTitle();
            }
        }
        if (remixer.compare(song->getRemixer())  && (!boost::regex_match(remixer, match1, decimal) || !boost::regex_match(song->getRemixer(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!remixer.empty()) {
                cout << "updating song " << id << " remixer from " << song->getRemixer() << " to " << remixer << endl;
                needsUpdate = true;
            } else {
                remixer = song->getRemixer();
            }
        }
        if (featuring.compare(song->getFeaturing())  && (!boost::regex_match(featuring, match1, decimal) || !boost::regex_match(song->getFeaturing(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!featuring.empty()) {
                cout << "updating song " << id << " featuring from " << song->getFeaturing() << " to " << featuring << endl;
                needsUpdate = true;
            } else {
                featuring = song->getFeaturing();
            }
        }
        if (filepath.compare(song->getFilepath())  && (!boost::regex_match(filepath, match1, decimal) || !boost::regex_match(song->getFilepath(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!filepath.empty()) {
                cout << "updating song " << id << " filepath from " << song->getFilepath() << " to " << filepath << endl;
                needsUpdate = true;
            } else {
                filepath = song->getFilepath();
            }
        }
        if (rating != song->getRating()) {
            if (rating) {
                cout << "updating song " << id << " rating from " << song->getRating() << " to " << rating << endl;
                needsUpdate = true;
            } else {
                rating = song->getRating();
            }
        }
        if (dateAdded != song->getDateAdded()) {
            if (!song->getDateAdded()) {
                cout << "updating song " << id << " dateAdded from " << song->getDateAdded() << " to " << dateAdded << endl;
                needsUpdate = true;
            } else {
                dateAdded = song->getDateAdded();
            }
        }
        if (bpm.compare(song->getBpm())  && (!boost::regex_match(bpm, match1, decimal) || !boost::regex_match(song->getBpm(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!bpm.empty()) {
                cout << "updating song " << id << " bpm from " << song->getBpm() << " to " << bpm << endl;
                needsUpdate = true;
            } else {
                bpm = song->getBpm();
            }
        }
        if (!equivalentSets<string>(tonicKeys, song->tonicKeys)) {
            if (!containsSet<string>(tonicKeys, song->tonicKeys)) {
                cout << "updating song " << id << " tonicKeys" << endl;
                needsUpdate = true;
            }
            tonicKeys.insert(song->tonicKeys.begin(), song->tonicKeys.end());
        }
        if (comments.compare(song->getComments())  && (!boost::regex_match(comments, match1, decimal) || !boost::regex_match(song->getComments(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!comments.empty()) {
                cout << "updating song " << id << " comments from " << song->getComments() << " to " << comments << endl;
                needsUpdate = true;
            } else {
                comments = song->getComments();
            }
        }
        if (trashed != song->getTrashed()) {
            if (trashed) {
                cout << "updating song " << id << " trashed from " << song->getTrashed() << " to " << trashed << endl;
                needsUpdate = true;
            } else {
                trashed = song->getTrashed();
            }
        }
        if (lowQuality != song->getLowQuality()) {
            if (lowQuality) {
                cout << "updating song " << id << " lowQuality from " << song->getLowQuality() << " to " << lowQuality << endl;
                needsUpdate = true;
            } else {
                lowQuality = song->getLowQuality();
            }
        }
        if (reSongId != song->getRESongId()) {
            if (reSongId) {
                cout << "updating song " << id << " reSongId from " << song->getRESongId() << " to " << reSongId << endl;
                needsUpdate = true;
            } else {
                reSongId = song->getRESongId();
            }
        }
        if (reSong) needsUpdate |= reSong->sync();
        if (albumId != song->getAlbumId()) {
            if (albumId) {
                cout << "updating song " << id << " albumId from " << song->getAlbumId() << " to " << albumId << endl;
                needsUpdate = true;
            } else {
                albumId = song->getAlbumId();
            }
        }
        if (album) needsUpdate |= album->sync();
        if (albumPartId != song->getAlbumPartId()) {
            if (albumPartId) {
                cout << "updating song " << id << " albumPartId from " << song->getAlbumPartId() << " to " << albumPartId << endl;
                needsUpdate = true;
            } else {
                albumPartId = song->getAlbumPartId();
            }
        }
        if (albumPart) needsUpdate |= albumPart->sync();
        if (!equivalentVectors<int>(stylesIds, song->stylesIds)) {
            if (!containsVector<int>(stylesIds, song->stylesIds)) {
                cout << "updating song " << id << " stylesIds" << endl;
                needsUpdate = true;
            }
            appendUniqueVector<int>(song->stylesIds, &stylesIds);
            styles.clear();
        }
        return needsUpdate;
    }

    int Song::update() {
        try {
            if (reSong && reSong->sync()) {
                reSong->update();
            }
            if (album && album->sync()) {
                album->update();
            }
            if (albumPart && albumPart->sync()) {
                albumPart->update();
            }
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("update Songs set artist=?, track=?, title=?, remixer=?, featuring=?, filepath=?, rating=?, dateAdded=?, bpm=?, tonicKeys=?, comments=?, trashed=?, lowQuality=?, reSongId=?, albumId=?, albumPartId=? where id=?");
            ps->setString(1, artist);
            ps->setString(2, track);
            ps->setString(3, title);
            ps->setString(4, remixer);
            ps->setString(5, featuring);
            ps->setString(6, filepath);
            ps->setInt(7, rating);
            ps->setString(8, stringFromTime(dateAdded));
            ps->setString(9, bpm);
            ps->setString(10, setToCsv(tonicKeys));
            ps->setString(11, comments);
            ps->setBoolean(12, trashed);
            ps->setBoolean(13, lowQuality);
            ps->setInt(14, reSongId);
            ps->setInt(15, albumId);
            if (albumPartId > 0) ps->setInt(16, albumPartId);
            else ps->setNull(16, sql::DataType::INTEGER);
            ps->setInt(17, id);
            int result = ps->executeUpdate();
            if (!stylesIds.empty()) {
                ps = MysqlAccess::getInstance().getPreparedStatement("insert ignore into SongStyles (songId, styleId) values (?, ?)");
                for (vector<int>::const_iterator it = stylesIds.begin(); it != stylesIds.end(); ++it) {
                    ps->setInt(1, id);
                    ps->setInt(2, *it);
                    ps->executeUpdate();
                }
            }
            return result;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    int Song::save() {
        try {
            if (reSong && (!reSong->getId() || !RESong::findById(reSong->getId()))) {
                if (reSong->save()) {
                    if (reSong->getId()) {
                        reSongId = reSong->getId();
                    } else {
                        reSongId = MysqlAccess::getInstance().getLastInsertId();
                        reSong->setId(reSongId);
                    }
                } else {
                    cerr << "Unable to save reSong" << endl;
                }
            }
            if (album && (!album->getId() || !Album::findById(album->getId()))) {
                if (album->save()) {
                    if (album->getId()) {
                        albumId = album->getId();
                    } else {
                        albumId = MysqlAccess::getInstance().getLastInsertId();
                        album->setId(albumId);
                    }
                } else {
                    cerr << "Unable to save album" << endl;
                }
            }
            if (albumPart && (!albumPart->getId() || !AlbumPart::findById(albumPart->getId()))) {
                if (albumPart->save()) {
                    if (albumPart->getId()) {
                        albumPartId = albumPart->getId();
                    } else {
                        albumPartId = MysqlAccess::getInstance().getLastInsertId();
                        albumPart->setId(albumPartId);
                    }
                } else {
                    cerr << "Unable to save albumPart" << endl;
                }
            }
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("insert into Songs (artist, track, title, remixer, featuring, filepath, rating, dateAdded, bpm, tonicKeys, comments, trashed, lowQuality, reSongId, albumId, albumPartId) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
            ps->setString(1, artist);
            ps->setString(2, track);
            ps->setString(3, title);
            ps->setString(4, remixer);
            ps->setString(5, featuring);
            ps->setString(6, filepath);
            ps->setInt(7, rating);
            ps->setString(8, stringFromTime(dateAdded));
            ps->setString(9, bpm);
            ps->setString(10, setToCsv(tonicKeys));
            ps->setString(11, comments);
            ps->setBoolean(12, trashed);
            ps->setBoolean(13, lowQuality);
            ps->setInt(14, reSongId);
            ps->setInt(15, albumId);
            if (albumPartId > 0) ps->setInt(16, albumPartId);
            else ps->setNull(16, sql::DataType::INTEGER);
            int saved = ps->executeUpdate();
            if (!saved) {
                cerr << "Not able to save song" << endl;
                return saved;
            } else {
                id = MysqlAccess::getInstance().getLastInsertId();
                if (id == 0) {
                    cerr << "Inserted song, but unable to retreive inserted ID." << endl;
                    return saved;
                }
                ps = MysqlAccess::getInstance().getPreparedStatement("insert ignore into SongStyles (songId, styleId) values (?, ?)");
                for (vector<int>::iterator it = stylesIds.begin(); it != stylesIds.end(); ++it) {
                    ps->setInt(1, id);
                    ps->setInt(2, *it);
                    if (!ps->executeUpdate()) {
                        cerr << "Did not save style for song " << id << endl;
                    }
                }
                return saved;
            }
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }


# pragma mark accessors

    const int Song::getId() const { return id; }
    void Song::setId(const int id) { this->id = id; }

    const string& Song::getArtist() const { return artist; }
    void Song::setArtist(const string& artist) { this->artist = artist; }

    const string& Song::getTrack() const { return track; }
    void Song::setTrack(const string& track) { this->track = track; }

    const string& Song::getTitle() const { return title; }
    void Song::setTitle(const string& title) { this->title = title; }

    const string& Song::getRemixer() const { return remixer; }
    void Song::setRemixer(const string& remixer) { this->remixer = remixer; }

    const string& Song::getFeaturing() const { return featuring; }
    void Song::setFeaturing(const string& featuring) { this->featuring = featuring; }

    const string& Song::getFilepath() const { return filepath; }
    void Song::setFilepath(const string& filepath) { this->filepath = filepath; }

    const int Song::getRating() const { return rating; }
    void Song::setRating(const int rating) { this->rating = rating; }

    const time_t Song::getDateAdded() const { return dateAdded; }
    void Song::setDateAdded(const time_t dateAdded) { this->dateAdded = dateAdded; }

    const string& Song::getBpm() const { return bpm; }
    void Song::setBpm(const string& bpm) { this->bpm = bpm; }

    const set<string>& Song::getTonicKeys() const {
        return tonicKeys;
    }
    void Song::setTonicKeys(const set<string>& tonicKeys) {
        this->tonicKeys = tonicKeys;
    }
    void Song::addTonicKey(const string& tonicKey) {
        this->tonicKeys.insert(tonicKey);
    }
    void Song::removeTonicKey(const string& tonicKey) {
        this->tonicKeys.erase(tonicKey);
    }

    const string& Song::getComments() const { return comments; }
    void Song::setComments(const string& comments) { this->comments = comments; }

    const bool Song::getTrashed() const { return trashed; }
    void Song::setTrashed(const bool trashed) { this->trashed = trashed; }

    const bool Song::getLowQuality() const { return lowQuality; }
    void Song::setLowQuality(const bool lowQuality) { this->lowQuality = lowQuality; }

    const int Song::getRESongId() const { return reSongId; }
    void Song::setRESongId(const int reSongId) {
        this->reSongId = reSongId;
        delete reSong;
        reSong = NULL;
    }

    RESong* Song::getRESong() const {
        if (!reSong && reSongId)
            return RESong::findById(reSongId);
        return reSong;
    }
    void Song::setRESong(const RESong& reSong) {
        this->reSongId = reSong.getId();
        delete this->reSong;
        this->reSong = new RESong(reSong);
    }

    const int Song::getAlbumId() const { return albumId; }
    void Song::setAlbumId(const int albumId) {
        this->albumId = albumId;
        delete album;
        album = NULL;
    }

    Album* Song::getAlbum() const {
        if (!album && albumId)
            return Album::findById(albumId);
        return album;
    }
    void Song::setAlbum(const Album& album) {
        this->albumId = album.getId();
        delete this->album;
        this->album = new Album(album);
    }

    const int Song::getAlbumPartId() const { return albumPartId; }
    void Song::setAlbumPartId(const int albumPartId) {
        this->albumPartId = albumPartId;
        delete albumPart;
        albumPart = NULL;
    }

    AlbumPart* Song::getAlbumPart() const {
        if (!albumPart && albumPartId)
            return AlbumPart::findById(albumPartId);
        return albumPart;
    }
    void Song::setAlbumPart(const AlbumPart& albumPart) {
        this->albumPartId = albumPart.getId();
        delete this->albumPart;
        this->albumPart = new AlbumPart(albumPart);
    }

    const vector<Style*>& Song::getStyles() {
        if (styles.empty() && !stylesIds.empty()) {
            for (vector<int>::const_iterator it = stylesIds.begin(); it != stylesIds.end(); ++it) {
                styles.push_back(Style::findById(*it));
            }
        }
        return styles;
    }
    void Song::setStyles(const vector<Style*>& styles) {
        deleteVectorPointers<Style*>(&this->styles);
        this->styles = styles;
        this->stylesIds.clear();
        for (vector<Style*>::const_iterator it = styles.begin(); it != styles.end(); ++it) {
            this->stylesIds.push_back((*it)->getId());
        }
    }
    void Song::addStyleById(int styleId) {
        if (std::find(stylesIds.begin(), stylesIds.end(), styleId) == stylesIds.end()) {
                stylesIds.push_back(styleId);
                if (!styles.empty()) styles.push_back(Style::findById(styleId));
        }
    }
    void Song::removeStyleById(int styleId) {
        for (vector<Style*>::iterator it = styles.begin(); it != styles.end(); ++it) {
            if (styleId == (*it)->getId()) {
                delete (*it);
                styles.erase(it);
            }
        }
        for (vector<int>::iterator it = stylesIds.begin(); it != stylesIds.end(); ++it) {
            if (styleId == *it) {
                stylesIds.erase(it);
            }
        }
    }

}
}
