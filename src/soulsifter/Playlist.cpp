//
//  Playlist.cpp
//  soul-sifter
//
//  Created by Robby Neale
//  Generated by generate_model.rb
//

#include "Playlist.h"

#include <cmath>
#include <string>

#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>

#include <cppconn/connection.h>
#include <cppconn/statement.h>
#include <cppconn/prepared_statement.h>
#include <cppconn/resultset.h>
#include <cppconn/exception.h>
#include <cppconn/warning.h>

#include "MysqlAccess.h"
#include "DTVectorUtil.h"

using namespace std;

namespace dogatech {
namespace soulsifter {

# pragma mark initialization

    Playlist::Playlist() :
    id(0),
    name(),
    query(),
    songs(),
    songsIds() {
    }

    Playlist::Playlist(const Playlist& playlist) :
    id(playlist.getId()),
    name(playlist.getName()),
    query(playlist.getQuery()),
    songs(),
    songsIds(playlist.songsIds) {
    }

    void Playlist::operator=(const Playlist& playlist) {
        id = playlist.getId();
        name = playlist.getName();
        query = playlist.getQuery();
        songsIds = playlist.songsIds;
        deleteVectorPointers(&songs);
    }

    Playlist::~Playlist() {
        while (!songs.empty()) delete songs.back(), songs.pop_back();
    }

    void Playlist::clear() {
        id = 0;
        name.clear();
        query.clear();
        deleteVectorPointers(&songs);
        songsIds.clear();
    }

# pragma mark static methods

    void Playlist::populateFields(const sql::ResultSet* rs, Playlist* playlist) {
        playlist->setId(rs->getInt("id"));
        playlist->setName(rs->getString("name"));
        playlist->setQuery(rs->getString("query"));
        populateSongsIds(playlist);
    }

    void Playlist::populateSongsIds(Playlist* playlist) {
        sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select songId from PlaylistSongs where playlistId = ?");
        ps->setInt(1, playlist->getId());
        sql::ResultSet *rs = ps->executeQuery();
        while (rs->next()) {
            playlist->songsIds.push_back(rs->getInt(1));
        }
        rs->close();
        delete rs;
    }

    Playlist* Playlist::findById(int id) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Playlists where id = ?");
            ps->setInt(1, id);
            sql::ResultSet *rs = ps->executeQuery();
            Playlist *playlist = NULL;
            if (rs->next()) {
                playlist = new Playlist();
                populateFields(rs, playlist);
            }
            rs->close();
            delete rs;

            return playlist;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    Playlist* Playlist::findByName(const string& name) {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Playlists where name = ?");
            ps->setString(1, name);
            sql::ResultSet *rs = ps->executeQuery();
            Playlist *playlist = NULL;
            if (rs->next()) {
                playlist = new Playlist();
                populateFields(rs, playlist);
            }
            rs->close();
            delete rs;

            return playlist;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    ResultSetIterator<Playlist>* Playlist::findAll() {
        sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select * from Playlists");
        sql::ResultSet *rs = ps->executeQuery();
        ResultSetIterator<Playlist> *dtrs = new ResultSetIterator<Playlist>(rs);
        return dtrs;
    }

# pragma mark persistence

    bool Playlist::sync() {
        Playlist* playlist = findById(id);
        if (!playlist) {
            return true;
        }

        // check fields
        bool needsUpdate = false;
        boost::regex decimal("(-?\\d+)\\.?\\d*");
        boost::smatch match1;
        boost::smatch match2;
        if (id != playlist->getId()) {
            if (id) {
                cout << "updating playlist " << id << " id from " << playlist->getId() << " to " << id << endl;
                needsUpdate = true;
            } else {
                id = playlist->getId();
            }
        }
        if (name.compare(playlist->getName())  && (!boost::regex_match(name, match1, decimal) || !boost::regex_match(playlist->getName(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!name.empty()) {
                cout << "updating playlist " << id << " name from " << playlist->getName() << " to " << name << endl;
                needsUpdate = true;
            } else {
                name = playlist->getName();
            }
        }
        if (query.compare(playlist->getQuery())  && (!boost::regex_match(query, match1, decimal) || !boost::regex_match(playlist->getQuery(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!query.empty()) {
                cout << "updating playlist " << id << " query from " << playlist->getQuery() << " to " << query << endl;
                needsUpdate = true;
            } else {
                query = playlist->getQuery();
            }
        }
        if (!equivalentVectors<int>(songsIds, playlist->songsIds)) {
            if (!containsVector<int>(songsIds, playlist->songsIds)) {
                cout << "updating playlist " << id << " songsIds" << endl;
                needsUpdate = true;
            }
            appendUniqueVector<int>(playlist->songsIds, &songsIds);
            songs.clear();
        }
        return needsUpdate;
    }

    int Playlist::update() {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("update Playlists set name=?, query=? where id=?");
            ps->setString(1, name);
            ps->setString(2, query);
            ps->setInt(3, id);
            int result = ps->executeUpdate();
            if (!songsIds.empty()) {
                ps = MysqlAccess::getInstance().getPreparedStatement("insert ignore into PlaylistSongs (playlistId, songId) values (?, ?)");
                for (vector<int>::const_iterator it = songsIds.begin(); it != songsIds.end(); ++it) {
                    ps->setInt(1, id);
                    ps->setInt(2, *it);
                    ps->executeUpdate();
                }
            }
            return result;
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }

    int Playlist::save() {
        try {
            sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("insert into Playlists (name, query) values (?, ?)");
            ps->setString(1, name);
            ps->setString(2, query);
            int saved = ps->executeUpdate();
            if (!saved) {
                cerr << "Not able to save playlist" << endl;
                return saved;
            } else {
                id = MysqlAccess::getInstance().getLastInsertId();
                if (id == 0) {
                    cerr << "Inserted playlist, but unable to retreive inserted ID." << endl;
                    return saved;
                }
                ps = MysqlAccess::getInstance().getPreparedStatement("insert ignore into PlaylistSongs (playlistId, songId) values (?, ?)");
                for (vector<int>::iterator it = songsIds.begin(); it != songsIds.end(); ++it) {
                    ps->setInt(1, id);
                    ps->setInt(2, *it);
                    if (!ps->executeUpdate()) {
                        cerr << "Did not save song for playlist " << id << endl;
                    }
                }
                return saved;
            }
        } catch (sql::SQLException &e) {
            cerr << "ERROR: SQLException in " << __FILE__;
            cerr << " (" << __func__<< ") on line " << __LINE__ << endl;
            cerr << "ERROR: " << e.what();
            cerr << " (MySQL error code: " << e.getErrorCode();
            cerr << ", SQLState: " << e.getSQLState() << ")" << endl;
            exit(1);
        }
    }


# pragma mark accessors

    const int Playlist::getId() const { return id; }
    void Playlist::setId(const int id) { this->id = id; }

    const string& Playlist::getName() const { return name; }
    void Playlist::setName(const string& name) { this->name = name; }

    const string& Playlist::getQuery() const { return query; }
    void Playlist::setQuery(const string& query) { this->query = query; }

    const vector<Song*>& Playlist::getSongs() {
        if (songs.empty() && !songsIds.empty()) {
            for (vector<int>::const_iterator it = songsIds.begin(); it != songsIds.end(); ++it) {
                songs.push_back(Song::findById(*it));
            }
        }
        return songs;
    }
    void Playlist::setSongs(const vector<Song*>& songs) {
        deleteVectorPointers<Song*>(&this->songs);
        this->songs = songs;
        this->songsIds.clear();
        for (vector<Song*>::const_iterator it = songs.begin(); it != songs.end(); ++it) {
            this->songsIds.push_back((*it)->getId());
        }
    }
    void Playlist::addSongById(int songId) {
        if (std::find(songsIds.begin(), songsIds.end(), songId) == songsIds.end()) {
                songsIds.push_back(songId);
                if (!songs.empty()) songs.push_back(Song::findById(songId));
        }
    }
    void Playlist::removeSongById(int songId) {
        for (vector<Song*>::iterator it = songs.begin(); it != songs.end(); ++it) {
            if (songId == (*it)->getId()) {
                delete (*it);
                songs.erase(it);
            }
        }
        for (vector<int>::iterator it = songsIds.begin(); it != songsIds.end(); ++it) {
            if (songId == *it) {
                songsIds.erase(it);
            }
        }
    }

}
}
